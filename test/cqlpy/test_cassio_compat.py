# Copyright 2026-present ScyllaDB
#
# SPDX-License-Identifier: LicenseRef-ScyllaDB-Source-Available-1.0

###############################################################################
# Tests for Cassandra SAI (StorageAttachedIndex) API compatibility.
#
# The CassIO library creates indexes using the Cassandra
# SAI class name 'org.apache.cassandra.index.sai.StorageAttachedIndex'.
# ScyllaDB must accept this class name and translate it appropriately:
#   - For vector columns: translated to ScyllaDB's native 'vector_index'
#   - For non-vector columns (e.g., ENTRIES on MAP): translated to a native
#     secondary index
#
# These tests validate that CQL statements generated by CassIO
# work correctly on ScyllaDB.  Tests that exercise features supported by both
# ScyllaDB and Cassandra 5.0 (basic SAI indexing) run on either backend.
# Tests for ScyllaDB-specific extensions (source_model acceptance,
# case-insensitive class names) are marked scylla_only.
###############################################################################

import pytest
from .util import new_test_table, unique_name, is_scylla
from cassandra.protocol import InvalidRequest, ConfigurationException
from test.pylib.runner import testpy_test_fixture_scope

SAI_CLASS = 'org.apache.cassandra.index.sai.StorageAttachedIndex'


# Override the default test_keyspace_vnodes fixture: the target server may
# enforce tablets, making vnode-only keyspace creation impossible.  Yield None
# so that the test_keyspace fixture falls through to its default path.
@pytest.fixture(scope=testpy_test_fixture_scope)
def test_keyspace_vnodes(cql, this_dc, has_tablets):
    if not has_tablets:
        from .util import unique_name as _un
        name = _un()
        cql.execute("CREATE KEYSPACE " + name +
                     " WITH REPLICATION = { 'class' : 'NetworkTopologyStrategy', '"
                     + this_dc + "' : 1 }")
        yield name
        cql.execute("DROP KEYSPACE " + name)
    else:
        try:
            from .util import unique_name as _un
            name = _un()
            cql.execute("CREATE KEYSPACE " + name +
                         " WITH REPLICATION = { 'class' : 'NetworkTopologyStrategy', '"
                         + this_dc + "' : 1 } AND TABLETS = {'enabled': false}")
            yield name
            cql.execute("DROP KEYSPACE " + name)
        except ConfigurationException:
            yield None


# On ScyllaDB, vector indexes require tablets.  On Cassandra, SAI and vector
# types are native, so no tablet prerequisite exists.  This fixture skips a
# test only on ScyllaDB when tablets are not available.
@pytest.fixture(scope="function")
def scylla_with_tablets(cql, has_tablets):
    if is_scylla(cql) and not has_tablets:
        pytest.skip("ScyllaDB needs tablets for vector indexes")


# --- SAI vector index creation tests ---

def test_sai_vector_index_creation(cql, test_keyspace, scylla_with_tablets):
    """SAI class name should be accepted for creating a vector index on a
    VECTOR<FLOAT, N> column.  On ScyllaDB the class is translated to the
    native 'vector_index'; on Cassandra SAI handles it natively."""
    schema = 'p int PRIMARY KEY, v vector<float, 3>'
    with new_test_table(cql, test_keyspace, schema) as table:
        cql.execute(f"CREATE CUSTOM INDEX ON {table}(v) USING '{SAI_CLASS}'")


def test_sai_vector_index_with_similarity_function(cql, test_keyspace, scylla_with_tablets):
    """SAI vector index should accept the similarity_function option."""
    schema = 'p int PRIMARY KEY, v vector<float, 3>'
    for func in ['cosine', 'euclidean', 'dot_product']:
        with new_test_table(cql, test_keyspace, schema) as table:
            cql.execute(
                f"CREATE CUSTOM INDEX ON {table}(v) USING '{SAI_CLASS}' "
                f"WITH OPTIONS = {{'similarity_function': '{func}'}}"
            )


def test_sai_vector_index_with_source_model(cql, test_keyspace, scylla_only, skip_without_tablets):
    """SAI vector index should accept the source_model option (used by CassIO)
    without error, even though ScyllaDB does not use it."""
    schema = 'p int PRIMARY KEY, v vector<float, 3>'
    with new_test_table(cql, test_keyspace, schema) as table:
        cql.execute(
            f"CREATE CUSTOM INDEX ON {table}(v) USING '{SAI_CLASS}' "
            f"WITH OPTIONS = {{'similarity_function': 'dot_product', 'source_model': 'bert'}}"
        )


def test_sai_vector_index_source_model_only(cql, test_keyspace, scylla_only, skip_without_tablets):
    """SAI vector index should accept source_model even without
    similarity_function."""
    schema = 'p int PRIMARY KEY, v vector<float, 3>'
    with new_test_table(cql, test_keyspace, schema) as table:
        cql.execute(
            f"CREATE CUSTOM INDEX ON {table}(v) USING '{SAI_CLASS}' "
            f"WITH OPTIONS = {{'source_model': 'openai-v3-small'}}"
        )


def test_sai_short_class_name(cql, test_keyspace, scylla_with_tablets):
    """The short class name 'StorageAttachedIndex' should also be accepted."""
    schema = 'p int PRIMARY KEY, v vector<float, 3>'
    with new_test_table(cql, test_keyspace, schema) as table:
        cql.execute(
            f"CREATE CUSTOM INDEX ON {table}(v) USING 'StorageAttachedIndex'"
        )


def test_sai_class_name_case_insensitive(cql, test_keyspace, scylla_only, skip_without_tablets):
    """SAI class name matching should be case-insensitive."""
    schema = 'p int PRIMARY KEY, v vector<float, 3>'
    with new_test_table(cql, test_keyspace, schema) as table:
        cql.execute(
            f"CREATE CUSTOM INDEX ON {table}(v) "
            f"USING 'org.apache.cassandra.index.sai.STORAGEATTACHEDINDEX'"
        )


# --- SAI ENTRIES index on MAP (metadata filtering) ---

def test_sai_entries_index_on_map(cql, test_keyspace):
    """SAI ENTRIES index on a MAP column should work.  On ScyllaDB the
    SAI class is translated to a native secondary index; on Cassandra
    SAI handles it natively.  This is the CassIO metadata-filtering pattern."""
    schema = 'p int PRIMARY KEY, metadata_s map<text, text>'
    with new_test_table(cql, test_keyspace, schema) as table:
        cql.execute(
            f"CREATE CUSTOM INDEX ON {table}(ENTRIES(metadata_s)) "
            f"USING '{SAI_CLASS}'"
        )


def test_sai_entries_index_on_map_multiple(cql, test_keyspace):
    """Multiple SAI ENTRIES indexes on different MAP columns should work."""
    schema = 'p int PRIMARY KEY, m1 map<text, text>, m2 map<text, int>'
    with new_test_table(cql, test_keyspace, schema) as table:
        idx1 = unique_name()
        idx2 = unique_name()
        cql.execute(
            f"CREATE CUSTOM INDEX {idx1} ON {table}(ENTRIES(m1)) "
            f"USING '{SAI_CLASS}'"
        )
        cql.execute(
            f"CREATE CUSTOM INDEX {idx2} ON {table}(ENTRIES(m2)) "
            f"USING '{SAI_CLASS}'"
        )


def test_sai_values_index_on_regular_column(cql, test_keyspace):
    """SAI on a regular (non-vector, non-collection) column should work.
    On ScyllaDB the SAI class is translated to a native secondary index;
    on Cassandra SAI handles it natively."""
    schema = 'p int PRIMARY KEY, x text'
    with new_test_table(cql, test_keyspace, schema) as table:
        cql.execute(
            f"CREATE CUSTOM INDEX ON {table}(x) USING '{SAI_CLASS}'"
        )


# --- SAI on non-vector column should not be treated as vector_index ---

def test_sai_on_int_column_ignores_vector_options(cql, test_keyspace, scylla_only):
    """When SAI is used on a non-vector column, it becomes a native secondary
    index.  Native secondary indexes silently ignore unknown options, so
    vector-specific options like similarity_function are accepted without
    error — they simply have no effect."""
    schema = 'p int PRIMARY KEY, x int'
    with new_test_table(cql, test_keyspace, schema) as table:
        # This should succeed without error — the SAI class is stripped and
        # options are passed through to the native index which ignores them.
        cql.execute(
            f"CREATE CUSTOM INDEX ON {table}(x) USING '{SAI_CLASS}' "
            f"WITH OPTIONS = {{'similarity_function': 'cosine'}}"
        )


# --- CassIO-style full table creation pattern ---

def test_cassio_vector_table_pattern(cql, test_keyspace, scylla_only, skip_without_tablets):
    """Test the full CassIO vector table creation pattern:
    1. Create table with vector column and metadata map
    2. Create SAI vector index on the vector column
    3. Create SAI ENTRIES index on the metadata map"""
    schema = (
        'row_id text PRIMARY KEY, '
        'body_blob text, '
        'vector_col vector<float, 5>, '
        'metadata_s map<text, text>'
    )
    with new_test_table(cql, test_keyspace, schema) as table:
        vec_idx = unique_name()
        meta_idx = unique_name()
        cql.execute(
            f"CREATE CUSTOM INDEX {vec_idx} ON {table}(vector_col) "
            f"USING '{SAI_CLASS}' "
            f"WITH OPTIONS = {{'similarity_function': 'dot_product', 'source_model': 'bert'}}"
        )
        cql.execute(
            f"CREATE CUSTOM INDEX {meta_idx} ON {table}(ENTRIES(metadata_s)) "
            f"USING '{SAI_CLASS}'"
        )


def test_cassio_if_not_exists(cql, test_keyspace, scylla_with_tablets):
    """IF NOT EXISTS should work with SAI class name, same as with
    'vector_index'."""
    schema = 'p int PRIMARY KEY, v vector<float, 3>'
    with new_test_table(cql, test_keyspace, schema) as table:
        idx = unique_name()
        cql.execute(
            f"CREATE CUSTOM INDEX IF NOT EXISTS {idx} ON {table}(v) "
            f"USING '{SAI_CLASS}'"
        )
        # Creating the same index again with IF NOT EXISTS should not fail
        cql.execute(
            f"CREATE CUSTOM INDEX IF NOT EXISTS {idx} ON {table}(v) "
            f"USING '{SAI_CLASS}'"
        )


# --- Invalid SAI usage ---

def test_sai_on_nonexistent_column(cql, test_keyspace, scylla_with_tablets):
    """SAI on a non-existent column should fail with an appropriate error."""
    schema = 'p int PRIMARY KEY, v vector<float, 3>'
    with new_test_table(cql, test_keyspace, schema) as table:
        with pytest.raises(InvalidRequest, match="No column definition found|Undefined column name"):
            cql.execute(
                f"CREATE CUSTOM INDEX ON {table}(nonexistent) USING '{SAI_CLASS}'"
            )


def test_sai_invalid_class_still_rejected(cql, test_keyspace):
    """Other invalid custom class names should still be rejected."""
    schema = 'p int PRIMARY KEY, v vector<float, 3>'
    with new_test_table(cql, test_keyspace, schema) as table:
        with pytest.raises((InvalidRequest, ConfigurationException),
                           match="Non-supported custom class|Unable to find custom indexer class"):
            cql.execute(
                f"CREATE CUSTOM INDEX ON {table}(v) "
                f"USING 'org.apache.cassandra.index.InvalidIndex'"
            )
